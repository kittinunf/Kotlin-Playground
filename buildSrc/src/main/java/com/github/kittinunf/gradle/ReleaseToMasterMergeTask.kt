package com.github.kittinunf.gradle

import com.github.kittinunf.fuel.core.FuelError
import com.github.kittinunf.fuel.forge.responseObject
import com.github.kittinunf.github.GithubApi
import com.github.kittinunf.github.GithubPR
import com.github.kittinunf.github.MERPAY
import com.github.kittinunf.github.githubPRDeserializer
import com.github.kittinunf.result.Result
import com.github.kittinunf.result.flatMap
import com.github.kittinunf.result.map
import com.jcraft.jsch.JSch
import com.jcraft.jsch.Session
import org.eclipse.jgit.api.CreateBranchCommand.SetupUpstreamMode
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.MergeCommand.FastForwardMode.NO_FF
import org.eclipse.jgit.api.TransportConfigCallback
import org.eclipse.jgit.lib.Ref
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.eclipse.jgit.transport.JschConfigSessionFactory
import org.eclipse.jgit.transport.OpenSshConfig
import org.eclipse.jgit.transport.SshTransport
import org.eclipse.jgit.transport.Transport
import org.eclipse.jgit.util.FS
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.nio.charset.Charset
import java.text.SimpleDateFormat
import java.util.*

open class ReleaseToMasterMergeTask : DefaultTask() {

    companion object {
        const val SSH_FILE_PATH = "~/.ssh/id_rsa"
    }

    @Input
    lateinit var token: String

    @TaskAction
    fun processTask() {
        val git = FileRepositoryBuilder().setGitDir(File("${project.rootDir}/.git")).build().let(::Git)

        val branches = git.lsRemote()
            .setTransportConfigCallback(SshConfig(SSH_FILE_PATH))
            .call()
            .filter { it.name.contains("release/") }

        Result.of(branches.takeIf { it.isNotEmpty() }, { error("No release branch") })
            .flatMap {
                println(">>> Found branch: ${it.first()}, Create temp branch")
                createTempBranchName(it.first(), git)
            }
            .flatMap { (releaseRef, tmpBranch) ->
                createReleaseBranch(releaseRef, git).map { it to tmpBranch }
            }
            .flatMap { (releaseRef, tmpBranch) ->
                println(">>> Merge content of $releaseRef to $tmpBranch")
                mergeNoFFWithBranch(releaseRef, tmpBranch, git)
            }
            .flatMap {
                println(">>>> Create PR and update assignee")
                createGithubPR(it)
            }
            .fold(success = {
                println(">>>> Success")
                println(it)
            }, failure = {
                println(">>>> Failure")
                println(it.message)

                (it as? FuelError)?.let {
                    print(it.response)
                    println(it.response.data.toString(Charset.defaultCharset()))
                }
            })
    }

    private fun createTempBranchName(branch: Ref, git: Git) = Result.of {
        val tmpBranch = "ci/${branch.name.replace("refs/heads/release/", "")}_to_master"

        // delete
        git.branchDelete()
            .setForce(true)
            .setBranchNames(tmpBranch).call()

        // create
        git.branchCreate()
            .setName(tmpBranch)
            .call()

        // checkout
        git.checkout()
            .setName(tmpBranch)
            .call()

        branch to tmpBranch
    }

    private fun createReleaseBranch(branch: Ref, git: Git) = Result.of {
        val name = branch.name.replace("refs/heads/", "")
        git.fetch().setTransportConfigCallback(SshConfig(SSH_FILE_PATH)).call()
        git.branchCreate()
            .setUpstreamMode(SetupUpstreamMode.SET_UPSTREAM)
            .setName(name)
            .setStartPoint("origin/$name")
            .setForce(true)
            .call()
    }

    private fun mergeNoFFWithBranch(branch: Ref, currentBranch: String, git: Git) = Result.of {
        val mergeResult = git.merge()
            .include(branch)
            .setFastForward(NO_FF)
            .setMessage(
                "CI commit to merge ref ${branch.name} at " +
                        SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault()).format(Date())
            )
            .call()

        if (!mergeResult.mergeStatus.isSuccessful) {
            throw error(mergeResult.toString())
        }

        git.push()
            .setTransportConfigCallback(SshConfig(SSH_FILE_PATH))
            .call()

        currentBranch
    }

    private fun createGithubPR(branchName: String): Result<GithubPR, FuelError> {
        val (_, _, result) =
            GithubApi.PR.Create(MERPAY, title = "[CI] Merge $branchName into master", body = "Generated by `${javaClass.simpleName}`", branch = branchName)
                .withToken(token)
                .call()
                .responseObject(githubPRDeserializer)

        return result.flatMap {
            GithubApi.Issue.Update(MERPAY, it.number, "kouzoh-ci")
                .withToken(token)
                .call()
                .responseObject(githubPRDeserializer)
                .third
        }
    }
}

class SshConfig(val sshKeyPath: String) : TransportConfigCallback {
    override fun configure(transport: Transport?) {
        (transport as SshTransport).sshSessionFactory = object : JschConfigSessionFactory() {
            override fun configure(hc: OpenSshConfig.Host?, session: Session?) {}

            override fun createDefaultJSch(fs: FS?): JSch = super.createDefaultJSch(fs).apply {
                addIdentity(sshKeyPath)
            }
        }
    }
}
